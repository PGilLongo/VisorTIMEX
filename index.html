<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>TIMEX • Visor (Lista)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    :root{
      --win-bg:#c0c0c0;
      --win-hi:#ffffff;
      --win-mid:#dfdfdf;
      --win-lo:#808080;
      --win-shadow:#404040;
      --title:#000080;
      --title-text:#ffffff;
      --tooltip:#ffffe1;
      --black:#000000;
      --ui-font:12px/1.2 "MS Sans Serif","Tahoma",system-ui,sans-serif;
      --ui-font-small:11px/1.2 "MS Sans Serif","Tahoma",system-ui,sans-serif;
    }

    html, body, #map { height: 100%; margin: 0; }
    body{
      background:#000080;
      font: var(--ui-font);
      color:#000;
    }

    .status-dot{
      position: fixed;
      z-index: 10000;
      right: 10px;
      top: 10px;
      width: 12px;
      height: 12px;
      background: var(--win-bg);
      border-top: 2px solid var(--win-hi);
      border-left: 2px solid var(--win-hi);
      border-right: 2px solid var(--win-shadow);
      border-bottom: 2px solid var(--win-shadow);
      box-sizing: border-box;
    }
    .status-dot.ok{ background:#00a000; }
    .status-dot.bad{ background:#a00000; }
    .status-dot.warn{ background:#a07a00; }

    .panel{
      position: fixed;
      z-index: 10000;
      left: 12px;
      top: 12px;
      max-width: calc(100vw - 24px);
      min-width: 260px;
      background: var(--win-bg);
      border-top: 2px solid var(--win-hi);
      border-left: 2px solid var(--win-hi);
      border-right: 2px solid var(--win-shadow);
      border-bottom: 2px solid var(--win-shadow);
      padding: 0;
      user-select: none;
      overflow: hidden;
      box-sizing: border-box;
    }

    .titlebar{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      padding: 3px 6px;
      background: var(--title);
      color: var(--title-text);
      font-weight: 700;
      letter-spacing: .1px;
      white-space: nowrap;
    }

    .content{ padding: 8px; }

    .group{
      border-top: 2px solid var(--win-shadow);
      border-left: 2px solid var(--win-shadow);
      border-right: 2px solid var(--win-hi);
      border-bottom: 2px solid var(--win-hi);
      padding: 8px;
      background: var(--win-bg);
    }

    .row{
      display:flex;
      align-items:center;
      gap: 6px;
      flex-wrap: wrap;
    }

    .hint{
      margin-top: 6px;
      font: var(--ui-font-small);
      color:#000;
      opacity:.75;
      user-select: text;
    }

    .btn{
      appearance: none;
      background: var(--win-bg);
      color: #000;
      border-top: 2px solid var(--win-hi);
      border-left: 2px solid var(--win-hi);
      border-right: 2px solid var(--win-shadow);
      border-bottom: 2px solid var(--win-shadow);
      padding: 4px 10px;
      font: var(--ui-font);
      cursor: pointer;
      white-space: nowrap;
      flex-shrink: 0;
    }
    .btn:active{
      border-top: 2px solid var(--win-shadow);
      border-left: 2px solid var(--win-shadow);
      border-right: 2px solid var(--win-hi);
      border-bottom: 2px solid var(--win-hi);
      padding: 5px 9px 3px 11px;
    }
    .btn.small{
      padding: 4px 8px;
      font-size: 11px;
      line-height: 1.2;
      font-family: "MS Sans Serif","Tahoma",system-ui,sans-serif;
    }

    .filelist, .results{
      margin-top: 8px;
      overflow: auto;
      padding: 6px;
      background: #fff;
      border-top: 2px solid var(--win-shadow);
      border-left: 2px solid var(--win-shadow);
      border-right: 2px solid var(--win-hi);
      border-bottom: 2px solid var(--win-hi);
      box-sizing: border-box;
    }
    .filelist{ max-height: min(24vh, 240px); }
    .results{ max-height: min(52vh, 520px); }

    .item{
      display: flex;
      align-items: center;
      gap: 10px;
      padding: 6px 8px;
      margin-bottom: 6px;
      background: #fff;
      border-bottom: 1px solid #d0d0d0;
      width: fit-content;
      max-width: 100%;
    }

    .ileft{
      display:flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }
    .iname{
      font-weight: 700;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 38ch;
    }
    .isub{
      font-weight: 400;
      color:#000;
      opacity: .75;
      font-size: 11px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      max-width: 56ch;
    }

    .leaflet-tooltip.name-tooltip{
      border-radius: 0;
      padding: 2px 6px;
      font: var(--ui-font-small);
      white-space: nowrap;
      border: 1px solid var(--black);
      background: var(--tooltip);
      box-shadow: none;
    }
    .leaflet-tooltip.name-tooltip:before{ display:none; }

    .leaflet-popup-content-wrapper{
      border-radius: 0;
      background: var(--win-bg);
      color: #000;
      border-top: 2px solid var(--win-hi);
      border-left: 2px solid var(--win-hi);
      border-right: 2px solid var(--win-shadow);
      border-bottom: 2px solid var(--win-shadow);
      box-shadow: none;
      padding: 0;
    }
    .leaflet-popup-content{
      margin: 0;
      padding: 8px 10px;
      font: var(--ui-font);
    }
    .leaflet-popup-tip{
      background: var(--win-bg);
      box-shadow: none;
      border-left: 2px solid var(--win-hi);
      border-top: 2px solid var(--win-hi);
      border-right: 2px solid var(--win-shadow);
      border-bottom: 2px solid var(--win-shadow);
    }
    .leaflet-container a.leaflet-popup-close-button{
      width: 18px;
      height: 18px;
      line-height: 16px;
      text-align: center;
      padding: 0;
      margin: 4px 4px 0 0;
      color: #000;
      font: 12px/1 "MS Sans Serif","Tahoma",system-ui,sans-serif;
      background: var(--win-bg);
      border-top: 2px solid var(--win-hi);
      border-left: 2px solid var(--win-hi);
      border-right: 2px solid var(--win-shadow);
      border-bottom: 2px solid var(--win-shadow);
      opacity: 1;
      border-radius: 0;
    }
    .leaflet-container a.leaflet-popup-close-button:hover{ color:#000; }
    .leaflet-container a.leaflet-popup-close-button:active{
      border-top: 2px solid var(--win-shadow);
      border-left: 2px solid var(--win-shadow);
      border-right: 2px solid var(--win-hi);
      border-bottom: 2px solid var(--win-hi);
      padding-top: 1px;
      padding-left: 1px;
    }
    .leaflet-popup-content b{ font-weight: 700; }

    input[type="file"]{ display:none; }
  </style>
</head>

<body>
  <div id="map"></div>
  <div id="statusDot" class="status-dot" title="Iniciando…"></div>

  <div class="panel">
    <div class="titlebar">TIMEX - Lista de recursos</div>

    <div class="content">
      <div class="group">
        <div class="row">
          <label class="btn" for="fileInput">Cargar KMZ/KML</label>
          <button class="btn small" id="fitAllBtn" type="button">Ver todo</button>
        </div>
        <div class="hint">Los KMZ/KML son locales con persistencia.</div>

        <input id="fileInput" type="file" accept=".kmz,.kml,application/vnd.google-earth.kmz,application/vnd.google-earth.kml+xml" multiple />
        <div class="filelist" id="fileList"></div>
      </div>

      <div class="results" id="results"></div>
    </div>
  </div>

  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/jszip@3.10.1/dist/jszip.min.js"></script>
  <script src="https://unpkg.com/@tmcw/togeojson@5.6.2/dist/togeojson.umd.js"></script>

  <script>
    (() => {
      "use strict";

      const CFG = {
        WEBAPP_URL: "https://script.google.com/macros/s/AKfycby9LjuP_t_d9TPOmSvZ7l5flFaOenmdF5Gb0QEX8ovY1M4GNDBc6a7i8TCFb-9et-NQOw/exec",
        TOKEN: "1234",
        REFRESH_MS: 1000,
        DEFAULT_CENTER: [40.4168, -3.7038],
        DEFAULT_ZOOM: 6,
        SHEET_ICON_SIZE: 70,
        SHEET_ANCHOR: [25, 50],
        DB_NAME: "timex_local_kmz",
        DB_VERSION: 1,
        STORE_FILES: "files"
      };

      const $ = (id) => document.getElementById(id);

      const el = {
        results: $("results"),
        statusDot: $("statusDot"),
        fileInput: $("fileInput"),
        fileList: $("fileList"),
        fitAllBtn: $("fitAllBtn")
      };

      const sheetMarkers = new Map();
      const iconCache = new Map();
      const localLayers = new Map();

      const HTML_ESC = { "&": "&amp;", "<": "&lt;", ">": "&gt;", "\"": "&quot;", "'": "&#39;" };

      let map;
      let firstFit = false;
      let loopTimer = null;
      let inflightController = null;
      let running = false;

      const safeNum = (v) => {
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
      };

      const escapeHtml = (s) => String(s).replace(/[&<>"']/g, (ch) => HTML_ESC[ch] || ch);

      const uid = () => (globalThis.crypto && typeof globalThis.crypto.randomUUID === "function")
        ? globalThis.crypto.randomUUID()
        : `id_${Date.now().toString(36)}_${Math.random().toString(36).slice(2)}`;

      const isAbort = (e) => e && (e.name === "AbortError" || String(e.message || "").toLowerCase().includes("aborted"));

      const setStatus = (kind, title) => {
        el.statusDot.classList.remove("ok", "bad", "warn");
        el.statusDot.classList.add(kind);
        if (title) el.statusDot.title = title;
      };

      const buildIcon = (url) => {
        if (!url) return null;
        const key = `${url}|${CFG.SHEET_ICON_SIZE}|${CFG.SHEET_ANCHOR[0]}|${CFG.SHEET_ANCHOR[1]}`;
        const cached = iconCache.get(key);
        if (cached) return cached;

        const icon = L.icon({
          iconUrl: url,
          iconSize: [CFG.SHEET_ICON_SIZE, CFG.SHEET_ICON_SIZE],
          iconAnchor: [CFG.SHEET_ANCHOR[0], CFG.SHEET_ANCHOR[1]]
        });
        iconCache.set(key, icon);
        return icon;
      };

      const bindNameTooltip = (marker, text) => {
        marker.unbindTooltip();
        if (!text) return;
        marker.bindTooltip(text, {
          permanent: true,
          direction: "top",
          offset: [0, -(CFG.SHEET_ICON_SIZE / 2)],
          className: "name-tooltip",
          opacity: 1
        });
      };

      const fetchTextWithTimeout = async (url, { signal, timeoutMs = 10000 } = {}) => {
        const ctrl = new AbortController();
        const t = setTimeout(() => ctrl.abort(), timeoutMs);

        if (signal) {
          if (signal.aborted) ctrl.abort();
          else signal.addEventListener("abort", () => ctrl.abort(), { once: true });
        }

        try {
          const res = await fetch(url, { cache: "no-store", signal: ctrl.signal });
          const text = await res.text();
          return { res, text };
        } finally {
          clearTimeout(t);
        }
      };

      const fetchSheetPoints = async () => {
        if (inflightController) inflightController.abort();
        inflightController = new AbortController();

        const url = `${CFG.WEBAPP_URL}?mode=readAll&token=${encodeURIComponent(CFG.TOKEN)}&v=${Date.now()}`;
        const { res, text } = await fetchTextWithTimeout(url, { signal: inflightController.signal });

        if (!res.ok) throw new Error(`HTTP ${res.status}`);

        let data;
        try {
          data = JSON.parse(text);
        } catch {
          throw new Error("JSON inválido");
        }

        const points = Array.isArray(data?.points) ? data.points : [];
        return points
          .map((p) => ({
            id: String(p?.id ?? ""),
            lat: safeNum(p?.lat),
            lng: safeNum(p?.lng),
            name: String(p?.name ?? ""),
            iconUrl: String(p?.iconUrl ?? "")
          }))
          .filter((p) => p.id && p.lat !== null && p.lng !== null);
      };

      const ensureSheetMarkerEntry = (p) => {
        const label = p.name || p.id;
        const existing = sheetMarkers.get(p.id);

        if (!existing) {
          const icon = p.iconUrl ? buildIcon(p.iconUrl) : null;
          const marker = L.marker([p.lat, p.lng], { icon: icon || undefined }).addTo(map);
          marker.bindPopup(`<b>${escapeHtml(label)}</b><br>${p.lat.toFixed(6)}, ${p.lng.toFixed(6)}`);
          bindNameTooltip(marker, label);
          sheetMarkers.set(p.id, { ...p, marker });
          return;
        }

        const moved = existing.lat !== p.lat || existing.lng !== p.lng;
        const renamed = existing.name !== p.name;
        const iconChanged = existing.iconUrl !== p.iconUrl;

        existing.lat = p.lat;
        existing.lng = p.lng;
        existing.name = p.name;
        existing.iconUrl = p.iconUrl;

        if (moved) existing.marker.setLatLng([p.lat, p.lng]);

        if (iconChanged) {
          const icon = p.iconUrl ? buildIcon(p.iconUrl) : null;
          existing.marker.setIcon(icon || new L.Icon.Default());
        }

        if (renamed || moved || iconChanged) {
          const newLabel = existing.name || existing.id;
          existing.marker.bindPopup(`<b>${escapeHtml(newLabel)}</b><br>${existing.lat.toFixed(6)}, ${existing.lng.toFixed(6)}`);
          bindNameTooltip(existing.marker, newLabel);
        }
      };

      const centerOnSheetId = (id) => {
        const e = sheetMarkers.get(id);
        if (!e) return;
        map.setView([e.lat, e.lng], Math.max(map.getZoom(), 14), { animate: true });
        e.marker.openPopup();
      };

      const renderCards = (container, items, makeCard) => {
        container.replaceChildren();
        if (!items.length) return;
        const frag = document.createDocumentFragment();
        for (const it of items) frag.appendChild(makeCard(it));
        container.appendChild(frag);
      };

      const makeSheetCard = (e) => {
        const row = document.createElement("div");
        row.className = "item";

        const left = document.createElement("div");
        left.className = "ileft";

        const name = document.createElement("div");
        name.className = "iname";
        name.textContent = e.name || e.id;

        const sub = document.createElement("div");
        sub.className = "isub";
        sub.textContent = `${e.id} • ${e.lat.toFixed(5)}, ${e.lng.toFixed(5)}`;

        left.appendChild(name);
        left.appendChild(sub);

        const btn = document.createElement("button");
        btn.className = "btn";
        btn.type = "button";
        btn.textContent = "Centrar";
        btn.addEventListener("click", () => centerOnSheetId(e.id));

        row.appendChild(left);
        row.appendChild(btn);
        return row;
      };

      const renderSheetList = () => {
        const items = [...sheetMarkers.values()].sort((a, b) => (a.name || a.id).localeCompare((b.name || b.id), "es"));
        renderCards(el.results, items, makeSheetCard);
      };

      const refreshOnce = async () => {
        setStatus("warn", "Actualizando…");
        try {
          const pts = await fetchSheetPoints();
          const present = new Set();

          for (const p of pts) {
            present.add(p.id);
            ensureSheetMarkerEntry(p);
          }

          for (const [id, entry] of sheetMarkers.entries()) {
            if (!present.has(id)) {
              map.removeLayer(entry.marker);
              sheetMarkers.delete(id);
            }
          }

          if (!firstFit && pts.length) {
            map.fitBounds(pts.map((p) => [p.lat, p.lng]), { padding: [50, 50] });
            firstFit = true;
          }

          renderSheetList();
          setStatus("ok", `OK • ${pts.length} punto(s)`);
        } catch (e) {
          if (isAbort(e)) return;
          setStatus("bad", "Error al actualizar");
        }
      };

      const startLoop = () => {
        if (running) return;
        running = true;

        const tick = async () => {
          if (!running) return;
          await refreshOnce();
          if (!running) return;
          loopTimer = setTimeout(tick, CFG.REFRESH_MS);
        };

        tick();
      };

      const stopLoop = () => {
        running = false;
        if (loopTimer) {
          clearTimeout(loopTimer);
          loopTimer = null;
        }
        if (inflightController) {
          inflightController.abort();
          inflightController = null;
        }
      };

      const DB = (() => {
        let dbPromise = null;

        const open = () => {
          if (dbPromise) return dbPromise;
          dbPromise = new Promise((resolve, reject) => {
            const req = indexedDB.open(CFG.DB_NAME, CFG.DB_VERSION);
            req.onupgradeneeded = () => {
              const db = req.result;
              if (!db.objectStoreNames.contains(CFG.STORE_FILES)) {
                db.createObjectStore(CFG.STORE_FILES, { keyPath: "id" });
              }
            };
            req.onsuccess = () => resolve(req.result);
            req.onerror = () => reject(req.error || new Error("IndexedDB error"));
          });
          return dbPromise;
        };

        const tx = async (mode, fn) => {
          const db = await open();
          return new Promise((resolve, reject) => {
            const t = db.transaction(CFG.STORE_FILES, mode);
            t.onerror = () => reject(t.error || new Error("DB error"));
            fn(t.objectStore(CFG.STORE_FILES), resolve, reject);
          });
        };

        return {
          getAll: async () => {
            const db = await open();
            return new Promise((resolve, reject) => {
              const t = db.transaction(CFG.STORE_FILES, "readonly");
              const req = t.objectStore(CFG.STORE_FILES).getAll();
              req.onsuccess = () => resolve(Array.isArray(req.result) ? req.result : []);
              req.onerror = () => reject(req.error || new Error("DB read error"));
            });
          },
          put: (record) => tx("readwrite", (store, resolve, reject) => {
            const req = store.put(record);
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error || new Error("DB write error"));
          }),
          del: (id) => tx("readwrite", (store, resolve, reject) => {
            const req = store.delete(id);
            req.onsuccess = () => resolve(true);
            req.onerror = () => reject(req.error || new Error("DB delete error"));
          })
        };
      })();

      const textFromArrayBuffer = (buf) => new TextDecoder("utf-8").decode(buf);

      const kmzToKmlText = async (arrayBuffer) => {
        const zip = await JSZip.loadAsync(arrayBuffer);
        const names = Object.keys(zip.files || {});
        const kmlName = names.find((n) => n.toLowerCase().endsWith(".kml")) || names.find((n) => n.toLowerCase().includes(".kml"));
        if (!kmlName) throw new Error("KMZ sin KML");
        const file = zip.file(kmlName);
        if (!file) throw new Error("KML no encontrado");
        return file.async("string");
      };

      const kmlTextToGeoJson = (kmlText) => {
        const xml = new DOMParser().parseFromString(kmlText, "text/xml");
        if (xml.getElementsByTagName("parsererror")?.length) throw new Error("KML inválido");

        const tj = (globalThis.toGeoJSON && typeof globalThis.toGeoJSON.kml === "function")
          ? globalThis.toGeoJSON
          : (globalThis.togeojson && typeof globalThis.togeojson.kml === "function" ? globalThis.togeojson : null);

        if (!tj) throw new Error("toGeoJSON no disponible");
        return tj.kml(xml);
      };

      const isValidBounds = (b) => !!(b && typeof b.isValid === "function" && b.isValid());

      const renderFileList = () => {
        const items = [...localLayers.values()].sort((a, b) => (a.name || "").localeCompare((b.name || ""), "es"));
        if (!items.length) {
          el.fileList.replaceChildren();
          const empty = document.createElement("div");
          empty.className = "hint";
          empty.textContent = "No hay archivos locales cargados.";
          el.fileList.appendChild(empty);
          return;
        }
        renderCards(el.fileList, items, makeLocalCard);
      };

      const addGeoJsonLayer = ({ id, name, geojson }) => {
        const prev = localLayers.get(id);
        if (prev) map.removeLayer(prev.layer);

        const layer = L.geoJSON(geojson, {
          onEachFeature: (feature, l) => {
            const props = feature?.properties || {};
            const title = props.name || props.Name || name || "Elemento";
            const desc = props.description || props.Description || "";
            const html = `<b>${escapeHtml(title)}</b>` + (desc ? `<br>${escapeHtml(String(desc))}` : "");
            if (l && typeof l.bindPopup === "function") l.bindPopup(html);
          }
        }).addTo(map);

        const bounds = (layer.getBounds && layer.getBounds()) || null;
        localLayers.set(id, { id, name, layer, bounds: isValidBounds(bounds) ? bounds : null });
        renderFileList();
      };

      const parseAndAddLocalRecord = async (rec) => {
        const ext = String(rec?.ext || "").toLowerCase();
        if (!rec?.id || !rec?.data || (ext !== "kml" && ext !== "kmz")) throw new Error("Registro inválido");

        const kmlText = ext === "kml"
          ? textFromArrayBuffer(rec.data)
          : await kmzToKmlText(rec.data);

        const geojson = kmlTextToGeoJson(kmlText);
        addGeoJsonLayer({ id: rec.id, name: rec.name || rec.id, geojson });
      };

      const fitAll = () => {
        const boundsList = [];

        const pts = [...sheetMarkers.values()];
        if (pts.length) {
          const b = L.latLngBounds(pts.map((p) => [p.lat, p.lng]));
          if (isValidBounds(b)) boundsList.push(b);
        }

        for (const e of localLayers.values()) {
          if (isValidBounds(e.bounds)) boundsList.push(e.bounds);
        }

        if (!boundsList.length) return;

        let merged = boundsList[0];
        for (let i = 1; i < boundsList.length; i++) merged = merged.extend(boundsList[i]);

        map.fitBounds(merged, { padding: [50, 50] });
      };

      const makeLocalCard = (e) => {
        const row = document.createElement("div");
        row.className = "item";

        const left = document.createElement("div");
        left.className = "ileft";

        const title = document.createElement("div");
        title.className = "iname";
        title.textContent = e.name;

        const sub = document.createElement("div");
        sub.className = "isub";
        sub.textContent = "KMZ/KML local";

        left.appendChild(title);
        left.appendChild(sub);

        const btnCenter = document.createElement("button");
        btnCenter.className = "btn small";
        btnCenter.type = "button";
        btnCenter.textContent = "Centrar";
        btnCenter.addEventListener("click", () => {
          if (isValidBounds(e.bounds)) map.fitBounds(e.bounds, { padding: [50, 50] });
        });

        const btnDel = document.createElement("button");
        btnDel.className = "btn small";
        btnDel.type = "button";
        btnDel.textContent = "Borrar";
        btnDel.addEventListener("click", async () => {
          try {
            map.removeLayer(e.layer);
            localLayers.delete(e.id);
            await DB.del(e.id);
            renderFileList();
          } catch {
            setStatus("bad", "No se pudo borrar");
          }
        });

        row.appendChild(left);
        row.appendChild(btnCenter);
        row.appendChild(btnDel);
        return row;
      };

      const handleLocalFileSelection = async (fileList) => {
        const files = Array.from(fileList || []);
        if (!files.length) return;

        for (const f of files) {
          const name = String(f?.name || "archivo");
          const lower = name.toLowerCase();
          const ext = lower.endsWith(".kmz") ? "kmz" : (lower.endsWith(".kml") ? "kml" : "");
          if (!ext) continue;

          try {
            const data = await f.arrayBuffer();
            const rec = {
              id: uid(),
              name,
              ext,
              size: data.byteLength,
              lastModified: Number(f.lastModified) || Date.now(),
              createdAt: Date.now(),
              data
            };

            await DB.put(rec);
            await parseAndAddLocalRecord(rec);
            setStatus("ok", `Cargado • ${name}`);
          } catch {
            setStatus("bad", `Error • ${name}`);
          }
        }

        el.fileInput.value = "";
      };

      const restoreLocalFiles = async () => {
        try {
          const all = await DB.getAll();
          if (!all.length) return renderFileList();

          all.sort((a, b) => (a.createdAt || 0) - (b.createdAt || 0));
          for (const rec of all) {
            try {
              await parseAndAddLocalRecord(rec);
            } catch {
              try { await DB.del(rec.id); } catch {}
            }
          }
          renderFileList();
        } catch {
          renderFileList();
        }
      };

      const wireUi = () => {
        el.fileInput.addEventListener("change", (ev) => handleLocalFileSelection(ev.target.files));
        el.fitAllBtn.addEventListener("click", fitAll);

        document.addEventListener("visibilitychange", () => {
          if (document.hidden) stopLoop();
          else startLoop();
        }, { passive: true });

        window.addEventListener("beforeunload", () => stopLoop(), { passive: true });
      };

      const main = () => {
        map = L.map("map", { preferCanvas: true, zoomControl: false }).setView(CFG.DEFAULT_CENTER, CFG.DEFAULT_ZOOM);
        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(map);

        wireUi();
        restoreLocalFiles();

        setStatus("warn", "Iniciando…");
        startLoop();
      };

      main();
    })();
  </script>
</body>
</html>
